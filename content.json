{"meta":{"title":"Fanghongliang's blog","subtitle":"Science && Truth","description":"站在巨人的肩膀上","author":"fanghl","url":"http://fanghl.top","root":"/"},"pages":[{"title":"404","date":"2019-09-19T12:36:20.000Z","updated":"2019-10-21T05:54:43.595Z","comments":true,"path":"404/index.html","permalink":"http://fanghl.top/404/index.html","excerpt":"","text":"404"},{"title":"分类","date":"2019-08-19T07:11:42.000Z","updated":"2019-10-21T05:54:43.627Z","comments":false,"path":"categories/index.html","permalink":"http://fanghl.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-19T11:49:32.000Z","updated":"2019-10-21T05:54:43.629Z","comments":true,"path":"tags/index.html","permalink":"http://fanghl.top/tags/index.html","excerpt":"","text":""},{"title":"Abort","date":"2019-09-19T11:40:28.000Z","updated":"2019-10-21T05:54:43.624Z","comments":true,"path":"about/index.html","permalink":"http://fanghl.top/about/index.html","excerpt":"","text":"我为何而生 &lt;伯特兰·罗素&gt; 有三种情感，单纯而强烈，支配着我的一生：对爱情的渴望，对知识的追求，以及对人类苦难不可遏制的同情。这些感情如阵阵巨风，挟卷着我在漂泊不定的路途中东飘西荡，飞越苦闷的汪洋大海，直抵绝望的边缘。 我之所以追寻爱情，首先，爱情使人心醉神迷，如此美妙的感觉，以致使我时常为了体验几小时爱的喜悦，而宁愿献出生命中其它一切；其次，爱情可以解除孤独，身历那种可怕孤寂的人的战栗意识，会穿过世界的边缘，直望入冰冷死寂的无底深渊；最后，置身于爱的结合，我在一个神秘缩影中看到了圣贤与诗人们所预想的天堂。这正是我所追寻的，尽管它对于人类的生活或许太过美好，却是我的最终发现。 我也以同样的热情追求知识。我渴望理解人类的心灵，渴望知道星辰为何闪耀，我还试图领略毕达哥拉斯关于哪些数字在变迁之上保持着永恒的智慧。在这一方面，我取得了一点成果，但并不算多。 爱情与知识，尽其可能，引领着我通往天堂；然而怜悯总是把我带回现实。那些痛苦的呼唤在我内心深处回响。饥饿中的孩子，被压迫和折磨的人们，给子女造成重担的无助老人，以及孤独、贫穷和痛苦的整个世界，都是对人类理想生活的嘲讽。我渴望能减少这些不幸，但无能为力，这也是我的痛苦。 这就是我的一生。我发现人生是值得的；而且如果能够再有一次这样的机会，我会欣然接受。"}],"posts":[{"title":"vue-wx-h5","slug":"vue-wx-h5","date":"2019-12-30T02:47:44.000Z","updated":"2019-12-30T06:20:57.926Z","comments":true,"path":"2019/12/30/vue-wx-h5/","link":"","permalink":"http://fanghl.top/2019/12/30/vue-wx-h5/","excerpt":"","text":"微信公众号总结由于微信的约定，在ios端无法购买虚拟产品，安卓则没有限制。为了解决ios用户也可以享受购买虚拟服务的问题，可适用公众号H5支付来解决ios端支付问题 准备由于仅仅是为ios用户解决支付问题，故此H5页面内容很简单，登录、拉取支付列表、支付即可。H5采用vue+jq实现，未适用vue-cli。（就俩页面，没必要）。页面结构如下： 鉴权需求鉴权，是微信提供的H5授权方式，一般采用第三方授权，授权成功获取code，用code获取acces_token、unionID等，由于H5是小程序ios支付的延伸，故此需要unionID来判断用户唯一性！鉴权必不可少。index.html文件中首先导入jsapi 鉴权网页授权与小程序不同，网页是第三方网页授权，然后授权信息在重定向链接中（redirect_uri）返回，重定向链接我设置为index.html页面。在 created（） 钩子中，去鉴权获取code 123456789101112131415161718192021222324252627282930313233created: function() &#123; const token = window.sessionStorage.getItem('token') //解决刷新问题 if(token) &#123; this.getCircleList() return &#125; let c = this.getQueryCode('code') this.code = c if(this.code) &#123; this.postData(c) &#125; else &#123; this.getUserCode() &#125; &#125;,//鉴权getUserCode() &#123; let redirect_uri = 'http://test.********.cn/projectName/' redirect_uri = encodeURI(redirect_uri) let url = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;this.appId&#125;&amp;redirect_uri=$&#123;redirect_uri&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirec` window.location.href = url&#125;,//获取鉴权成功后codegetQueryCode(variable) &#123; let query = window.location.search.substring(1) let v = query.split(\"&amp;\") for(let i = 0; i &lt; v.length; i++) &#123; let pair = v[i].split('=') if(pair[0] == variable) &#123; return pair[1] &#125; &#125; return null&#125;, 重点在于 getUserCode 鉴权函数,有人会在鉴权链接后面再加一个参数：&amp;connect_redirect=1 我第一次使用的链接就是加了该参数的，我只替换了APPID和重定向地址，结果一直报错，坑货。第二，重定向链接不能是本地连接，得是外网可以访问的链接。 支付页面中点击单个商品，进行支付购买。具体的支付过程和小程序支付一样，只不过这里多了wx.config 的应用。 1234567891011121314151617181920212223242526272829303132333435wx.config(&#123; debug: false, appId: that.appId, timestamp: timeStamp1, nonceStr, signature, jsApiList: ['chooseWXPay'] &#125;)wx.ready(function() &#123; wx.chooseWXPay(&#123; timestamp: timeStamp1, nonceStr, package: package1, signType, paySign, success: function (res) &#123; that.showSuccTip = true that.clickStatus = true that.getCircleList() setTimeout(() =&gt; &#123; that.showSuccTip = false &#125;, 1000*3) &#125;, cancel() &#123; that.clickStatus = true &#125;, fail(res) &#123; alert('支付失败,稍候再试') that.clickStatus = true &#125;, &#125;); &#125;)wx.error(function(res) &#123; console.log('config error : ', res)&#125;) 页面通信 - ajax没有使用axios,使用ajax通信，封装ajax通信 123456789101112131415161718192021222324httpAjax (obj) &#123; $.ajax(&#123; url: obj.url, data: obj.data &amp;&amp; obj.type === \"POST\" ? JSON.stringify(obj.data) : obj.data, type: obj.type ? obj.type : 'GET', contentType: 'application/json', beforeSend: function(xhr) &#123; if (obj.token) &#123; xhr.setRequestHeader('Authorization', '******** ' + obj.token); &#125; &#125;, dataType: 'json', success: function (res) &#123; if (typeof obj.success === 'function') &#123; obj.success(res) &#125; &#125;, error: function (res) &#123; if (typeof obj.error === 'function') &#123; obj.error(res) &#125; &#125; &#125;)&#125;, 页面效果这个效果，想到了使用jq解决，vue可能有更简单的方法，但没试过！ 123456789101112131415161718data: &#123; clickId: 0, &#125;//列表按钮携带自身idshowDetail(id) &#123; if(id == this.clickId) return $('#'+this.clickId).addClass('contentBox') $('#'+id).removeClass('contentBox') $('#'+id).find(\"[name='bigCircle']\").removeClass('greyLine') $('#'+this.clickId).find(\"[name='bigCircle']\").addClass('greyLine') $('#'+id).find(\"[name='smallCircle']\").addClass('hited') $('#'+this.clickId).find(\"[name='smallCircle']\").removeClass('hited') this.clickId = id&#125;, 采坑杂谈坑真的有点多，尤其是第一次搞得话。各种配置文件、微信公众平台里面的白名单，安全域名配置等等，token的传递坑了好久，跨域，没用vue-cli ，打开页面不能右击打开浏览器预览，使用 anywhere 插件来把路径转化为 http/HTTPS链接，后期测试直接把文件拉倒xshell服务器里面去测，要不Git分支被污染的不忍直视。 ios兼容ios端用户支付成功回调函数里面 alert 并不会被执行，Android则无影响。所以支付成功的提示自己写一个 alert 就可以。 刷新都快上线了，产品进入点了一个刷新，页面卡死报错！原因是鉴权返回的 code 一次性有效！，刷新时，链接其实没变，但是code已经过期了。解决： 页面刷新不影响逻辑，此时我们只需要token即可，故此把token存储在sessionStorage 里面即可避免页面刷新问题。","categories":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/categories/Programming/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"wepy-封装","slug":"wepy-wxminiPro","date":"2019-12-16T06:48:03.000Z","updated":"2019-12-30T06:41:36.348Z","comments":true,"path":"2019/12/16/wepy-wxminiPro/","link":"","permalink":"http://fanghl.top/2019/12/16/wepy-wxminiPro/","excerpt":"","text":"request封装目录结构： 目录： /utils/base.js 1234567891011121314151617181920212223242526272829303132333435363738394041import wepy from 'wepy'import qiniuyun = from '@/utils/qiniuUploader'const baseUrl = 'https://xxxx'//上传图片： const uploadImg = (imageURL, uptokenURL) &#123; return new Promise((resolve, reject) =&gt; &#123; qiniuyun.upload(imageURL, res =&gt; &#123; resolve(res) &#125;, error =&gt; &#123; reject(error) &#125;, &#123; region: 'ECN', domain: 'https://xxxx', uptoken: uptokenURL &#125;) &#125;) &#125;//请求封装const wxRequest = async (params = &#123;&#125;, url, method,) =&gt; &#123; let token = params.token || '' if(params.getToken) &#123; token = wepy,getStorageSync('token') &#125; let res = await wepy.request(&#123; url, method: methos || 'GET', data: params.data || &#123;&#125;, header: Object.assign(&#123; 'Content-Type': 'application/json', 'Accept': 'application/json', 'Authorization': `XqCircleToken $&#123;token&#125;` &#125;, params.header || &#123;&#125;) &#125;) return res&#125;module.exports = &#123; wxRequest, baseUrl, uploadImg,&#125;; 在 base.js 中封装请求，在api文件中则可以直接拿来使用目录： utils/api.js 12345678910import base from '@/utils/base'//登录、获取基本信息const login = (params) =&gt; base.wxRequest(params, `$&#123;base.baseUrl&#125;/login/`, 'POST')const getUserInfo = (params) =&gt; base.wxRequest(params, `$&#123;base.baseUrl&#125;/user/`,)module.exports = &#123; login, getBaseInfo,&#125; 统一管理维护所有的接口api， 在页面中，直接使用具体的api 1234567891011121314151617181920212223242526272829/** src/pages/index.wpy*/import api from '@/utils/api'//获取用户基本信息onShow() &#123; this.getUserInfo(params)&#125;//带参数，同步写法getUserInfo(params) &#123; api.getUserInfo(&#123; data: &#123; data: data1 &#125;, getToken: true &#125;).then(res =&gt; &#123; const data = res.data ... this.$apply() &#125;)&#125;//不带参数，异步写法async getUserInfo() &#123; let res = await api.getUserInfo(&#123;getToken: true&#125;) if(res.statusCode === 200) &#123; //doSth &#125;&#125; Mixins提出公共方法，方便全局调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/**path: scr/mixins/common*name: common*/import wepy from 'wepy'export default class commonMixins extends wepy.mixins &#123; //本地存储 saveData (k, v) &#123; wepy.setStorage(&#123; key: k, value: v &#125;) &#125; saveDataS(k, v)&#123; wepy.setStorageSync(k, v || '') &#125; getDataS(k)&#123; let res = wepy.getStorageSync(k); return res &#125; // 图片预览 preImg(c, u)&#123; wepy.previewImage(&#123; current: c, urls: u &#125;) &#125; // 提示框 toast(title,icon,dura)&#123; wepy.showToast(&#123; title: title, icon: icon, duration: dura || 1500 &#125;) &#125; //页面滚动 pageScro(num)&#123; wepy.pageScrollTo(&#123; scrollTop: num, duration: 0 &#125;); &#125; // 页面跳转 nav(url)&#123; this.$navigate(&#123; url: url &#125;) &#125; swi(url)&#123; wepy.switchTab(&#123; url: url &#125;) &#125; log() &#123; const show = true if (show) &#123; console.log(`[$&#123;new Date().Format(\"yyyy-MM-dd hh:mm:ss\")&#125;] `, ...arguments) &#125; &#125; // 发送formid postFormId(id)&#123; let arr = wepy.getStorageSync('form_ids') || []; arr.push(id); wepy.setStorageSync('form_ids', arr) &#125; // showModal modal(data) &#123; wx.showModal(&#123; content: data.content, showCancel: data.cancel || false, confirmText: data.confirm || '知道了', &#125;) &#125; //粘贴板 setClipboardData(data, succFun) &#123; wx.setClipboardData(&#123; data: 'data', success(res) &#123; wx.getClipboardData(&#123; success (res) &#123; succFun &#125; &#125;) &#125; &#125;) &#125; // 页面顶部title setNavTitle(title) &#123; wx.setNavigationBarTitle(&#123; title: title &#125;) &#125; //跳转小程序 navToMini(appId) &#123; wx.navigateToMiniProgram(&#123; appId, &#125;) &#125; //加载框 loading(title) &#123; wx.showLoading(&#123; title: title || \"加载中...\" &#125;) &#125; //隐藏加载框 hideLoading() &#123; wx.hideLoading(&#123;&#125;) &#125; //banner跳转 bannerJump(url) &#123; if(url.slogan == 1) &#123; this.swi(url.autoResponse1) return &#125; this.nav(url.autoResponse1) &#125; //返回上一个页面 navBack() &#123; wx.navigateBack(&#123;&#125;) &#125;&#125; 使用mixins ，在页面中引入，config中声明，即可在页面使用 this 调用 12345import commonMixin from '@/mixins/common'import req from '@/mixins/req' //页面配置中： mixins = [commonMixin, req] 常量配置数据前端配置数据抽离出来单独放，便于维护。 12345678910111213141516171819202122232425262728/***path: src/utils/configData.js*/const education = [ '高中及以下', '专科', '本科', '硕士', '博士',]//微信号码正则const wxreg=/^[a-zA-Z]&#123;1&#125;[-_a-zA-Z0-9]&#123;5,19&#125;$/;// banner轮播配置const swiperConfig = &#123; autoplay: true, interval: 3500, duration: 500, circular: true, indicatorDdots: true, indicatorColor: 'rgba(255,255,255,1)', indicatorActiveColor: '#FF8356',&#125;module.export = &#123; education, wxreg, swiperConfig,&#125; 分包小程序未超过2M大小，无需分包。超过2M，则采用分包，单包不超过2M，总计不超过8M。 分享普通分享略过。带shareTicket的分享，且需要记录分享群的信息时： 12345678910111213141516171819/**path: src/app.wpy**/async onShow(ops) &#123; const that = this; // 判断是否是群点击进入 console.log('APP show : ', ops) that.scene = ops.scene; if (ops.scene === 1044 &amp;&amp; ops.shareTicket !== undefined)&#123; that.shareTicket = ops.shareTicket; &#125;&#125;//页面async onShow() &#123; if(that.$parent.scene === 1044)&#123; await that.touchGroup(); &#125;&#125; 由分享进入小程序某个页面，需先判断缓存中是否存在 token ， 若不存在 token ， 则先请求登录接口，到后端换取 token ， 再请求其他api 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//某分享链接进入的页面async onShow() &#123; const that = this if( !wepy.getStorageSync('token')) &#123; await that.getLogin() &#125; that.getUserInfo()&#125;//mixins - reqasync getLogin()&#123; await wepy.login().then(async (res) =&gt; &#123; let result = await this.timeOut(circleApi.login(&#123; data: &#123; app_id: this.$parent.globalData.appId, code: res.code &#125; &#125;)); if(res.statusCode === 200)&#123; wepy.setStorage(&#123; key: \"token\", data: res.data.token &#125;) wepy.setStorage(&#123; key: 'user_id', data: res.data.user_id &#125;) &#125; &#125;)&#125;//超时处理async timeOut(fn)&#123; let that = this; let res = await Promise.race([this.test(), fn]).then((data) =&gt; &#123; return data &#125;); if(res === 'timeOut')&#123; that.toast('请检查网络或者重新试一下', 'none' ,1500); let status = &#123; statusCode: 300 &#125;; return status &#125;else &#123; return res &#125;&#125;// 请求超时处理test() &#123; let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('timeOut') &#125;,20000) &#125;); return promise;&#125; formid小程序给用户发送模板消息需要消耗 fromID， 新版的则是授权。这里记录一下fromID的处理。发送一条模板消息需耗费一个 fromIDfromID的存储应该是用户本次使用完小程序，然后把收集到的fromID一次性发送到后端 123456789101112131415161718192021222324252627282930313233/**path: src/app.wpy**/onHide()&#123; let form_ids = wepy.getStorageSync('form_ids'); configApi.postFormId(&#123; data: &#123; form_ids: form_ids &#125;, getToken: true &#125;); wepy.setStorageSync('form_ids', [])&#125;// mixins - common// 存储formid postFormId(id)&#123; let arr = wepy.getStorageSync('form_ids') || []; arr.push(id); wepy.setStorageSync('form_ids', arr) &#125;// 页面表单产生 fromID &lt;form @submit=\"submit\" report-submit=\"true\"&gt; &lt;button class=\"publicBox\" hover-class=\"none\" form-type=\"submit\"&gt; &lt;image class=\"publicImg\" src=\"../images/common/bigButton.png\" &gt;&lt;/image&gt; &lt;view class=\"publicText\"&gt;发布&lt;/view&gt; &lt;/button&gt;&lt;/form&gt;submit(e)&#123; this.postFormId( e.detail.formId )&#125;, 当用户的表单提交行为产生了 fromID 时， 统一进行本地存储，在用户沙雕该小程序时再统一提交全部fromid 登录广播","categories":[{"name":"wepy框架封装","slug":"wepy框架封装","permalink":"http://fanghl.top/categories/wepy框架封装/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"Emmet","slug":"Emmet","date":"2019-10-11T05:53:19.000Z","updated":"2019-10-21T05:54:43.599Z","comments":true,"path":"2019/10/11/Emmet/","link":"","permalink":"http://fanghl.top/2019/10/11/Emmet/","excerpt":"","text":"Emmet功能快速编辑前端HTML标签，以及编辑器标签自动闭合功能编辑器安装插件：Auto Close TagVscode编辑器中，【设置】中打开 Emmet相关配置 Emmet初始化12! =&gt; tabhtml:5 标签id/class/属性12div.test#testidp.test-class&#123;这里是p文本&#125; 嵌套&lt; : 子节点+ : 兄弟节点^ : 父节点 1div.aim-class&gt;div.son-class^div.brother1-class+div.brother2-class 分组() : 分组分组内的标签在层级上视为整体 1div&gt;(div&gt;div&gt;a)+div&gt;p&#123;test text&#125; 隐式标签直接通过 类 或 ID 生成标签可以省略掉div，即输入.item即可生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;隐式标签集合： 1234li：用于ul和ol中tr：用于table、tbody、thead和tfoot中td：用于tr中option：用于select和optgroup中 乘法* : 重复指令$ : 自增符号 12div*5ul&gt;li$*3 CSS缩写12w100 =&gt; width: 100pxh10p =&gt; height: 10% 单位别名列表:p 表示%e 表示 emx 表示 ex 更多参考： https://blog.csdn.net/comphoner/article/details/79670148","categories":[{"name":"html","slug":"html","permalink":"http://fanghl.top/categories/html/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"designMode","slug":"designMode","date":"2019-09-23T06:37:55.000Z","updated":"2019-10-21T05:54:43.604Z","comments":true,"path":"2019/09/23/designMode/","link":"","permalink":"http://fanghl.top/2019/09/23/designMode/","excerpt":"","text":"设计模式五大设计原则","categories":[{"name":"designMode","slug":"designMode","permalink":"http://fanghl.top/categories/designMode/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"Hexo建站","slug":"hexo","date":"2019-09-19T12:43:17.000Z","updated":"2019-11-25T11:53:45.811Z","comments":true,"path":"2019/09/19/hexo/","link":"","permalink":"http://fanghl.top/2019/09/19/hexo/","excerpt":"","text":"序言NEXT主题： http://theme-next.iissnan.com/getting-started.html参考文章： https://blog.csdn.net/sinat_37781304/article/details/82729029next参考: https://www.jianshu.com/p/5e56839ef917步骤： 12345678安装Git安装Node.js安装HexoGitHub创建个人仓库生成SSH添加到GitHub将hexo部署到GitHub设置个人域名发布文章 安装$ npm install hexo-cli -g安装后检查是否安装成功：$ hexo -v成功后进行初始化：$ hexo init myBlog安装组件: 1234$ cd myBlog$ npm install``` 至此，新建完成！目录会存在以下结构： node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题** _config.yml: 博客的配置文件** 1查看刚刚创建的hexo博客： $ hexo g$ hexo s 123456789打开localhost:4000就可以看到啦#### 创建GitHub仓库创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名#### hexo部署到GitHub将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 1此时需要安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub $ npm install hexo-deployer-git –save 1然后： $ hexo clean$ hexo generate$ hexo deploy $ hexo clean$ hexo d -g 1234567891011121314151617181920212223242526272829303132333435其中 deploy 时会要求输入 username 和 password （git账户密码） 之后，打开 http://yourname.github.io 这个网站就可以看到你的博客了！！#### 发布博客和线上GitHub关联后，新增一篇博客： `$ hexo new post &lt;your blogName&gt;` 编辑好文章发布部署： `$ hexo d -g `清除缓存： `$ hexo clean`#### 本地启Hexo动服务`$ hexo s || hexo serve` 默认端口：4000，修改端口号： `$ hexo serve -p 5000`#### 草稿#### 页面丰富##### 公益404：`$ hexo new page 404` 进入刚才生成的 \\source\\404\\index.md 添加： ```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; tags/标签页$ hexo new page tags配置tags页面，进入到刚才生成的 \\source\\tags\\index.md文件，添加type字段： 123title: 标签date: 2019-09-19 19:49:32type: &quot;tags&quot; 在文章中设置对应的标签即可： 1tags: [xxx,xxx,xxx] 分类页面/categories$ hexo new page categories配置categories页面，进入到刚才生成的 \\source\\categories\\index.md文件，添加type字段： 1234title: 分类date: 2019-08-19 15:11:42type: &quot;categories&quot;comments: false 设置每篇博客的 categories：categories: xxx 功能点字数统计、时长主题配置文件 _config.yml 中打开 wordcount 统计功能即可 123456post_wordcount: item_text: true wordcount: true #字数统计 min2read: true #阅读时长 totalcount: true separated_meta: true 配置之后还是没出现字数统计和阅读时长，可能是因为未安装 hexo-wordcount 插件，安装即可：$ npm insatll --save hexo-wordcount重启服务，OK 站内搜索安转插件npm install hexo-generator-searchdb --savehexo站点配置文件_config.yml,任意位置手动添加： 12345search: path: search.xml field: post format: html limit: 10000 修改主题(next)配置文件_config.yml,启用local_search 1234local_search: enable: true trigger: auto top_n_per_article: 1 ok hugo博客框架： go语言编写。多线程编译。速度快","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://fanghl.top/categories/Hexo/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"Charts","slug":"charts","date":"2019-09-17T02:33:17.000Z","updated":"2019-10-21T05:54:43.603Z","comments":true,"path":"2019/09/17/charts/","link":"","permalink":"http://fanghl.top/2019/09/17/charts/","excerpt":"","text":"序言antv蚂蚁官网： https://antv.alipay.com/zh-cn/index.html G2G2引入 CDN：&lt;script src=&quot;https://gw.alipayobjects.com/os/lib/antv/g2/3.4.10/dist/g2.min.js&quot;&gt;&lt;/script&gt; NPM:$ npm install @antv/g2 --saveimport G2 from &#39;@antv/g2&#39; 本地脚本：&lt;script src=&quot;./g2.js&quot;&gt;&lt;/script&gt; G2封装实战一个G2实例只能创建一个图表,若需要多个图表，可以封装G2 实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * G2 * charths函数 * warn:数据格式相同可复用一个函数,否则请重新另创图表函数 */// utils/charts.jsexport function chartInstance( point, chartData, config=&#123;&#125; ) &#123; const [axisX, axisValue, axisY] = Object.keys(chartData[0]) const chart = new G2.Chart(&#123; container: point, //point挂载点ID forceFit: config.width ? false : true, //表宽自适应配置 height: config.height || 600, width: config.width || null, //若配置forceFit，则width不生效 &#125;); chart.source(chartData, &#123; axisX: &#123; range: [0, 1], min: 0, max: 100 &#125; &#125;); chart.tooltip(&#123; crosshairs: &#123; type: 'line' &#125; &#125;); chart.axis(axisY, &#123; label: &#123; formatter: function formatter(val) &#123; return val + '￥'; &#125; &#125;, title: &#123; textStyle: &#123; fontSize: 12, // 文本大小 textAlign: 'center', // 文本对齐方式 fill: '#999', // 文本颜色 &#125; &#125;, line: &#123; lineDash: [3, 3] &#125; &#125;); chart.line().position(`$&#123;axisX&#125;*$&#123;axisY&#125;`).color(`$&#123;axisValue&#125;`).shape('smooth'); //平滑曲线图 chart.point().position(`$&#123;axisX&#125;*$&#123;axisY&#125;`).color(`$&#123;axisValue&#125;`).size(4).shape('circle').style(&#123; stroke: '#fff', lineWidth: 1 &#125;); chart.render(); return chart&#125;//showData.vueimport &#123; chartInstance&#125; from '@/utils/charts'data() &#123; return&#123; chartIncome:'', chartData2: [&#123;&#125;], &#125;&#125;,mounted() &#123; this.chartIncome = chartInstance('c1', this.chartData2) //返回值很重要，关乎数据变动 this.chartRegister = chartInstance('c2', this.chartData2) this.chartActive = chartInstance('c3', this.chartData2) &#125;,methods: &#123; //切换数据 onChangeIncome(e) &#123; const dateChange = e.target.value switch(dateChange) &#123; case 'a': this.chartIncome.changeData(this.chartData2) break case 'b': this.chartIncome.changeData(this.chartData3) break case 'c': this.chartIncome.changeData(this.chartData) break &#125; &#125;,&#125;","categories":[{"name":"Antv-G2","slug":"Antv-G2","permalink":"http://fanghl.top/categories/Antv-G2/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"javascript","slug":"js","date":"2019-09-12T08:25:21.000Z","updated":"2019-10-21T05:54:43.615Z","comments":true,"path":"2019/09/12/js/","link":"","permalink":"http://fanghl.top/2019/09/12/js/","excerpt":"","text":"Array属性：Array.length 方法：Array.from()从类数组对象或者可迭代对象中创建一个新的数组实例 123&lt;!-- 数组去重 --&gt;const arr = [1,3,5,56,3,2,1]const res = Array.from(new Set(arr)) Array.isArray()用来判断某个变量是否是一个数组对象。 12const obj = &#123;'key': 'value'&#125;Array.isArray(obj) // false Array.of()根据一组参数来创建新的数组实例，支持任意的参数数量和类型 Array instance属性：Array.prototype.constructor返回值 Array Array.prototype.length返回值长度 方法：修改器方法：下面的这些方法会改变调用它们的 对象自身 的值 123456789Array.prototype.copyWithin()Array.prototype.fill()Array.prototype.pop()Array.prototype.push()Array.prototype.reverse()Array.prototype.shift()Array.prototype.sort()Array.prototype.splice()Array.prototype.unshift() 访问方法：以下方法不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 12345678Array.prototype.concat()Array.prototype.includes()Array.prototype.join()Array.prototype.slice()Array.prototype.toString()Array.prototype.toLocaleString()Array.prototype.indexOf()Array.prototype.lastIndexOf() 迭代方法： 1234567Array.prototype.forEach()Array.prototype.every()Array.prototype.some()Array.prototype.filter()Array.prototype.map()Array.prototype.reduce()Array.prototype.reduceRight() String属性：String.prototype 方法：String.fromCharCode()通过一串 Unicode 创建字符串 String instance属性:String.prototype.constructor返回值 String String.prototype.length字符串长度 方法： 123456789101112131415161718192021222324252627282930String.prototype.charAt()String.prototype.charCodeAt()String.prototype.codePointAt()String.prototype.concat()String.prototype.includes()String.prototype.endsWith()String.prototype.indexOf()String.prototype.lastIndexOf()String.prototype.localeCompare()String.prototype.match()String.prototype.normalize()String.prototype.padEnd()String.prototype.padStart()String.prototype.repeat()String.prototype.replace()String.prototype.search()String.prototype.slice()String.prototype.split()String.prototype.startsWith()String.prototype.substr()String.prototype.substring()String.prototype.toLocaleLowerCase()String.prototype.toLocaleUpperCase()String.prototype.toLowerCase()String.prototype.toUpperCase()String.prototype.toString()String.prototype.trim()String.prototype.trimLeft()String.prototype.trimRight()String.prototype.valueOf() ObjectObject构造函数方法1234567891011121314151617181920Object.assign()Object.create()Object.defineProperty()Object.defineProperties()Object.entries()Object.freeze()Object.getOwnPropertyDescriptor()Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.getPrototypeOf()Object.is()Object.isExtensible()Object.isFrozen()Object.isSealed()Object.keys()Object.values()Object.preventExtensions()Object.seal()Object.setPrototypeOf()delete obj.property","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://fanghl.top/categories/Javascript/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"Git","slug":"Git","date":"2019-09-11T03:43:41.000Z","updated":"2019-12-30T06:59:23.502Z","comments":true,"path":"2019/09/11/Git/","link":"","permalink":"http://fanghl.top/2019/09/11/Git/","excerpt":"","text":"Git实用命令总结总结了部分开发中常用的git操作命令，根据实际业务遇到的情况梳理。包括但不限于分支新建、分支合并、分支合并冲突、dist文件冲突、版本回退等。 命名规范 标记 解释 feat 新功能 fix 修补bug doc 文档 style 格式，不影响代码 refactor 重构，不添加新功能，也非修补bug test 增加测试 chore 构建过程或辅助工程变动 scope 用于说明commit影响的范围 问题解决修改文件大小写Windows对大小写不敏感，git对大小写不敏感，需要修改文件名的大小写，实际修改了git却不会生效的，解决: 1. 复制此文件到其他地方备份 2. 删除项目中的该文件 3. 提交代码 4. 重新添加此文件到项目 5. 提交代码，over git实用命令git stash想要切换分支，本地却已经做了改变。切换会报错，此时可以使用 git stash保存当前的修改，等处理完其他分支事务在回来‘取出保存’的修改即可。 命令 作用说明 git stash 保存当前工作区和暂存区的修改 git stash save ‘注释信息’ 作用同上，加上了注释信息方便区分 git stash list 查看保存列表 git stash pop 恢复最近一次保存并删掉保存列表的记录，只恢复工作区 git stash pop –index 与上面命令的效果一样但是还会恢复暂存区！ git stash pop stash@{序号} 恢复保存列表里指定的保存记录，并把恢复的记录从保存列表中删除 git stash apply 恢复最近的保存记录但不会删除保存列表里面对应的记录 git stash drop 删除保存列表里面最近一条保存记录。后面加 stash@{序号}可以删除指定的保存记录 git stash clear 删除保存列表里面所以保存记录（清空保存列表） git stash 分支名 stash@{序号} 修改了文件，此次修该使用了 git stash 保存，然后继续修改了该文件，此时再用 git stash pop 或 git stash apply 恢复之前的保存，可能会出现冲突。此时使用该命令 git stash 分支名 stash@{序号} 会创建一个分支然后在创建的分支上把保存的记录恢复出来，避免冲突。 PS ： git stash 保存的修改可以跨分支应用。例如：在 develop分支上做了修改， *git stash保存，切换到 *master 分支，使用 pop 或 apply 拉出来保存，这样就可以把 develop 分支上修改的内容迁移到 master 上，解决冲突可能会遇到。 git撤回文件 命令 作用说明 git reset HEAD 放弃暂存区的修改（已经add,未commit） git checkout – * 放弃本地修改（未commit） git reset –soft HEAD^ 撤销commit 撤销线上仓库的commit适用于错误的push后没有他人再次push 12$ git reset --soft &lt;commitHash&gt;$ git push --force git revert撤销几次之前的commit，又需要保留该commit之后的提交时，需要用到 revert 123$ git log $ git revert commit_hash$ git push git reset 本质即把指针 HEAD 指向某一个 commitgit revert 本质不算是回滚，是反做，反向操作commit。正常情况下，每一次操作文件后会让 Git 时间线往前走一步，revert反向操作某一个commit 记录，并生成一个新的 commit 来反做 配置别名长命令的别名配置 1$ git config --global alias.st status 一个比较实用的别名配置↓ 1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 每个仓库的Git配置文件都放在.git/config文件中 1$ cat .git/config 12345[branch &quot;master&quot;] remote = originq merge = refs/heads/master[alias] last = log -1 //命令作用区域 配置别名也可以直接修改这个文件↑ 新建分支作业修改bug、添加新功能等，在主分支上开一个新分支进行作业，待作业完成后，再合并回主分支，并删掉新开的分支。 方法一：1234master分支$ git checkout master $ git checkout -b xqcircle origin/xqcircle //创建新分支并关联在远程同名分支上$ git push origin HEAD //把该分支推送到远程，即可以在git仓库看到 方法二：1234$ git branch dev $ git branch -a$ git branch -b branch_name //本地先创建该分支$ git push --set-upstream origin branch_name //本地分支推送到远程同名分支，且本地分支会自动track该分支 拉取分支远程存在分支，本地没有该分支，用以下命令拉下来 1$ git checkout --track origin/branch_name 合并回主分支12$ git checkout master$ git merge branch_name 删除远程分支12$ git branch -r -d origin/branch_name $ git push origin :branch_name 删除本地分支12$ git branch -d branch_name$ git branch -D branch_name 标签tag一个版本上线定义一个版本标签，方便快速回退该版本。 12git tag //列出所有taggit tag -l &apos;v2.0.1&apos; //过滤tag 新建tag1git tag xqCircle-v2.0.0 查看tag，commit号1git show tagName 给某个commit打上tag1git tag -a v1.0.0 commitId -m &apos;my tag&apos; 推送tag到服务器12git push origin tagName //推送某个具体taggit push origin --tags //推送本地所有tags 切换到某个tag跟分支一样，可以直接切换到某个tag去。这个时候不位于任何分支，处于游离状态 1git checkout xqCircle-v2.0.1 删除tag12git tag -d xqCircle-v2.0.1 //本地删除git push origin :refs/tags/xqCircle2.0.1 //远端删除","categories":[{"name":"Git","slug":"Git","permalink":"http://fanghl.top/categories/Git/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"python-Web框架之flask学习总结","slug":"flask","date":"2019-09-05T08:16:41.000Z","updated":"2019-10-21T05:54:43.609Z","comments":true,"path":"2019/09/05/flask/","link":"","permalink":"http://fanghl.top/2019/09/05/flask/","excerpt":"","text":"序言version： Python3.7.0内容环境Flask 和 Django 目前是Python较为流行的Web框架。区别大致在与毛坯房和拎包入住型公寓，flask比较适用于后台管理系统，Django适合前端项目提供接口，这不是废话嘛，因为公司的后台就是这样用的（此处手动狗头.jpg）Flask和node比较着学习，理解起来快且容易。这里忽略安装Python和flask的步骤，具体请传送https://dormousehole.readthedocs.io/en/latest/quickstart.html 入门123456from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_interface(): return &#123;\"status\": 'ok', 'data': 'mockdata'&#125; 上面的代码是最简单的Flask应用，运行后，通过postman测试localhost:5000端口，就可以拿到return里面的json数据，这点相比于node-Koa来说，返回的数据需要放在上下文（context）的body体中，有点简便啊洋葱圈模型中返回数据代码顺便复习一下： 1234567891011121314151617181920const Router = require('koa-router')const router = new Router()router.post('./v1/interface', (ctx, next) =&gt; &#123; const path = ctx.params const query = ctx.request.query const headers = ctx.request.header const body = ctx.request.body if( body.length == 0 ) &#123; const error = new global.errs.ParameterException('错误',605) &#125; if( query === 1 ) &#123; ctx.body = &#123; status: 'ok', code: 601, data: 'data' &#125; &#125;&#125;) Flask返回的数据模式相比Koa来说，太简略了吧，可能是一个get方法，一个post方法吧","categories":[{"name":"Python","slug":"Python","permalink":"http://fanghl.top/categories/Python/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"Python与JavaScript对照学习总结点","slug":"learnPython","date":"2019-08-28T08:16:41.000Z","updated":"2019-10-21T05:54:43.618Z","comments":true,"path":"2019/08/28/learnPython/","link":"","permalink":"http://fanghl.top/2019/08/28/learnPython/","excerpt":"","text":"序言Python： 廖雪峰-Python传送门： https://www.liaoxuefeng.com/wiki/1016959663602400命令行打开 .py 文件；Python交互环境，执行Python代码 缩进方式进行代码格式！！4格空格缩进大小写敏感 数据类型： 整数 浮点数 字符串 布尔值 =》 and, or, not 空值 None 列表 字典 变量: 常量，即不能变的变量，指针指向不变 类const，常量一般为变量名全部大写 全局变量：全局变量globalData的定义，在读完了教程之后也没发现关于全局变量的定义，基于js的思想，在js中，全局变量取决于该变量定义的位置，传统web编程中，未添加定义符号（var, let, const）的变量都可被称为”全局变量”,即使是 var 也存在一个变量提升的问题。Python中全局变量一般有两种方式： 声明式关键字 global 定义变量法。可以直接进行全局变量声明。global OLD_URL 模块法模块法和js大同小异，js中没有关键字 global ，但是模块引用也是非常好用的，在中大型项目中，我们把项目中用到的常量单独提取出来放置在js文件中。在通过 import 来导入使用。Python中也是如此。 除法： / 浮点数除法，即便是两个整数相除，结果也是浮点数 // 地板除，两个整数的除法仍然是整数，结果只取整数 10 // 3 =》 3 % 求模取余 字符串编码： ord() 数获取字符的整数表示 chr() 函数把编码转换为对应的字符Python的字符串类型是str，在内存中以Unicode表示Python对bytes类型的数据用带b前缀的单引号或双引号表示 x = b’abc’ encode() 方法可以编码为指定的bytes decode() 方法 把bytes变为str如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节： b’\\xe4\\xb8\\xad\\xff’.decode(‘utf-8’, errors=’ignore’) len() 方法计算str的字符数1个中文字符经过UTF-8编码占用3个字节，而1个英文字符只占用1个字节。 坚持 utf-8 编码 文件开头写上： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 格式化： Python与C一致，都采用 % 实现%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换&#39;age: %s. nmae: %s&#39; %(25, fhl) format() 格式化，比较麻烦 list 和 tuple : list : 列表。类数组 Arrayclassmates = [&#39;xaioming&#39;, &#39;xiaohua&#39;, &#39;xiaoliu&#39;]获取最后一个元素 classmates[len(classmates) - 1] 或者 classmates[-1] list 方法：append(content) 末尾插入insert(index, content) 插入指定位置pop() 删除末尾元素pop(index) 删除指定位置元素 tuple 元组，有序列表一旦初始化，不能更改。没有append、insert方法，其他和list一致因为不能更改，故更为安全，能用tuple代替list就尽量用tuple！t = (1,)t = (&#39;str&#39;, 23, [&#39;a&#39;]) 条件判断: 123456if age &gt;= 18: print('成年人')elif age &gt;= 1: print('幼儿期')else: print('婴儿期') int() 转化为整数函数 循环 for…in循环 while 循环 range() 生成一个整数序列,再通过list()函数可以转换为list break 退出循环 配合if使用 continue 跳过循环 配合if使用 使用dict和set：dictionary字典，其他语言叫map，使用key-value存储，也就是js的对象。json的话，本质是字符串，也可以类比吧。d = {&#39;name&#39;: &#39;fhl&#39;, &#39;age&#39;: 22, }PS: 区别点： js的对象可以使用 . 方法调用，Python目前只能 d[‘age’]或者 d.get(‘age’,-1)获取存储的值删除一个key，可以用 pop(key)dictionary是空间换时间的方法，list时间换空间 set同js中的key同根同源，存储key的集合,不存储value，且key不重复！！！创建set，需要一个list作为输入集合 add(key) 添加元素到set中，重复添加不会有效果 remove(key) 删除元素 set可看做成无序、无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等1234s1 = set([1, 3, 54])s2 = set([2, 3, 4])s1 &amp; s2 # 并 ，单个&amp; s1 | s2 # | 或，单个| 函数自带函数（内置函数）： abs() 、max()数据类型转换函数： int() float() str() bool() 参考js的数据转换函数 String() Number() Boolean() 定义函数：关键字： def, 依次写出函数名、括号、括号中的参数和冒号:,然后，在缩进块中编写函数体，函数的返回值用return语句返回类比js: 关键字function ，后面都一致，然后把 冒号 换成 js中的 大括号 即可 12345def my_abs(num): if x &gt;= 10: return x else: return -x 执行函数： 相比于Python，js的函数执行比较简单，定义完函数后，直接用函数名字加一对小括号就可以调用当前函数，但Python貌似得先导入该函数，才可以调用 12from test import my_absmy_abs(-1) pass关键字pass语句啥都不做，就和0一样，用来占位的。让程序可以跑起来。可以理解为斗地主时，你的牌大不过上家的，你就可以大吼一声： pass/过，让单线程的斗地主可以走下去，而不至于卡在这里，让队友喷你 Python函数返回值js函数没有return语句时，返回的是 undefined。Python返回的是 None，在存在返回多个值的情况下。Python返回的是tuple，一个tuple可以被好多个变量接收，具体场景参考ES6的解构赋值，一毛一样。 默认参数没啥好讲的，和ES6函数默认参数一毛一样，默认参数在后，必填参数在前 可变参数参数前面添加 * ，在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数，有点意思奥,即便我们的传参是list或者tuple，也可以在参数前加 * ，使得list或者 tuple 变为可变参数传进去 关键字参数**ky可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求 12345678def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 总结： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 递归函数：尾递归优化1234def fact(n): if n==1: return 1 return n * fact(n - 1) 以上代码是Python的递归代码，额，可能耦合性较高，函数内部使用了当前函数的名字，这高度耦合，在js里面我们可以通过 arguments.callee解决调用自身的问题，减小耦合。以下是js代码： 123456function fact(n) &#123; if( n == 1 ) &#123; return 1 &#125; return n * arguments.callee(n-1)&#125; 高级特性：切片 slice操作符slice切片操作符，简单来说，就是给js的slice()函数做了一个语法糖，其他都一致 12L[0:5] #[start:end]但不包括end，L为list或tupleL[-2:-1] #倒数第一个元素索引为-1 所有数，每5个取一个 123456L = list(range(100))L[:10] # 前十个数L[:-10] # 后十个数 L[:10:2] # 前10个数，每两个取一个L[::5] # 所有数，每5个取一个L[:] # 赋值list 切片也可以对字符串使用，不需要单独的类似substring()方法 迭代定义： 循环遍历list或者tuple，叫做迭代。迭代通过 for…in…来完成Python可以迭代一切可迭代的东西判断一个对象是否是可迭代对象呢？ 12from collections import Iterableisinstance('abc', Iterable) # 判断str是否是可迭代的对象，返回Boolean 列表生成式就是简化了复杂列表生成的繁琐步骤 1234567L = [] # 实现一个 1*1, 2*2,....10*10的列表for x in range(1, 11): # 传统方法 L.append( x * x )[x*x for x in range(1, 10)] # 列表生成器[x*x for x in range(1, 10) if x % 2 == 0 ] # 还可以加上 if 判断[m+n for m in 'abc' for n in 'xyz'] # 双层循环 接下来，这行代码可能会让jser稍微羡慕一下，那就是操作文件 12import os # 拿到了当前目录的所有文件夹[d for d in os.listdir('.')] js不能操作文件的，当然表亲 node.js是可以的dict的items() 方法可以同时迭代key和value，那么： 12d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125;[k + '=' + v for k, v in d.items() ] 12d = &#123;'Hello', 'WorLD'&#125; # 把list中所有的字符串小写[s.lower() for s in d] 生成器列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生generator 列表生成式的 [] 改成 () 即可创建生成器12L = [x * x for x in range(10) ] #列表生成式g = (x * x for x in range(10) ) # g是一个generator、next（）方法打印值 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误一般，generator用for来循环，不用next() 12for n in g: print(n) 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' PS::: enerator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 1234567g = fib()while True: try: x = next(g) except StopIteration as e: print('Generator return value:', e.value) break 迭代器可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()*判断一个对象是否是 *Iterable 对象 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用 isinstance() 判断一个对象是否是 Iterator 对象： 1isinstance([], Iterator) 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成 Iterator 可以使用 iter() 函数： 1isinstance(iter([]), Iterator) # True PS: Python的for循环本质上就是通过不断调用next()函数实现的 函数式编程高阶函数函数名是指向函数的变量（同js ），即函数本身可以被变量指着，在变量引用也是可以的一个函数接受另一个函数作为参数，这种函数称为高阶函数（同js） map/reducemap 和 js 的功能一致，即都是为 Iterable 的全部元素应用一种规则。这个规则一般是一个函数。不过语法上稍有不同,js的map是Array的一个方法。 python: map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 12345def f(x): return x*xr = map(f, [1, 2, 3, 4]) # 返回的是list每项的平方list(map(str, [1, 2, 32, 56]) # 把每一项变为字符串 123456789//js实现const arr = [1, 2, 3, 4]const r = arr.map(function(item) &#123; return item*item&#125;)// ES6const r = arr.map(item =&gt; &#123; return iten*item&#125;) 为什么js的map就只是Array的一个方法呢？我个人觉得。js的数据结构并没有Python那么灵活，因为js的for循环只能循环Array和Object，而反观Python就比较多了，本质来说，就是 Iterable 数据结构js只有Array和Object。而Python有很多，除了list和tuple，还有string也算，等等 reducereduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算,其效果就是： 1reduce(f,[x1, x2, x3]) = f(f(f(x1, x2,x3))) #三个f关系？其实这就说明了reduce()这个函数的作用了。 比如说序列求和： 1234from functools import reduce def add(x, y): return x + yreduce(add, [1, 3, 5, 7, 9]) #25 filter()和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 12def is_odd(n): return n % 2 == 1 js中的filter同样是Array的一个方法，用于过滤数组并返回一个新的数组 1234const arr = [5, 16, 35, 15, 48]const r = arr.filter(item =&gt; &#123; //返回r是一个大于18的数组 item &gt;= 18&#125;) 相比于js来说。Python的filter和map类似，都可以作用于Iterable数据类型 sorted()排序内置函数，用法和js的sort()类似。但是js的sort()方法在未传参数的情况下，默认按照字符编码的顺序进行排序。12L = [1, 5, 15, 25, 8]r = sorted(L) #1,5,8,15,25 js的sort(): 12345let arr = [1, 5, 15, 25, 8]arr.sort() // 1,15,25,5,8arr.sort(function(a, b)&#123; //1,5,8,15,25 return a - b&#125;) 看下sorted()的强大：可以传入三个参数，第一就是排序的list，第二个是key的规则，第三个是反转倒叙： 1sorted(['bov','lv','hln', 'Zomp'], key = str.lower, reverse = True) PS : sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数 返回函数简单看了下返回函数的定义，里面提到了闭包，这个js里面也经常提到的操作。简单说，闭包就是函数嵌套函数，内部的函数保存了外层函数的变量等参数，在外部函数被销毁后，内部函数依旧可以拿到外部函数的传参。这个概念js和Python没大的区别。深层次理解的话，参考另外一篇博客： https://www.cnblogs.com/fanghl/p/11417906.html 匿名函数关键字： lambda只能有一个表达式，不用写return，返回值就是表达式的结果 1234list(map(lambda x: x * x, [1, 3, 5, 7] ))#lambda x: 相当于：def f(x): return x * x python的匿名函数和js的匿名函数不太一样，但作用大都相似，不用担心函数名冲突等等，简化写法等。js里面的匿名函数已经升级到了ES6箭头函数模式，简单方便： 123456item =&gt; &#123; return item * item&#125;(x, y) =&gt; &#123; return x + y&#125; js里面匿名函数用的较少，一般都是用了箭头函数替代了。匿名函数的使用场景我也想不出多少，但在定时器中使用较多： 1234567891011function test() &#123; setTimeout(function() &#123; console.log(1) &#125;, 1000 * 2)&#125;// 不过一般都箭头简化了function test() &#123; setTimeout(() =&gt; &#123; console.log(1) &#125;, 1000 * 2)&#125; 装饰器代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数name 函数对象的该属性可以拿到函数的定义时名字没看懂，等懂了再回来写 偏函数个人理解又是一个语法糖！减少一些函数的繁杂写法关键模块：functools partial 123import functoolsint2 = functolls.partial(int, base = 2)# 创造一个偏函数int2，来进行2进制的转化，base是int内置函数固有的参数 模块模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用创建自己的模块时，要注意：模块名要遵循Python变量命名规范，不要使用中文、特殊字符；模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块 作用域__xxx__ 变量是特殊变量，可以被直接引用，但是有特殊用途_xxx或__xxx这样的函数或者变量是非公开的（private），不应该被直接引用 第三方模块安装 pip：安装第三方模块工具安装命令：pip install xxx 参照 npm 或者 yarn 包管理工具 安装常用模块 在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。Anaconda官网: https://www.anaconda.com/download/国内镜像： https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fpython 面向对象编程 OOP面向过程处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示 12std1 = &#123;'name': 'bob', 'score': 95&#125;std1 = &#123;'name': 'ming', 'score': 59&#125; 处理学生成绩通过函数实现，打印学生成绩： 12def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向过程，顾名思义，关心的是程序下一步怎么走？这个过程如何保持正确的走法。而面向对象，即万物皆对象，我们要考虑学生这个对象，然后直接创建这个对象，需要什么功能直接调用这个对象上面的方法即可，不用管过程！ 面向对象1234567891011121314class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score))xiaoming = Student('xiaoming', 95)xiaohong = Student('xiaohong', 59)xiaoming.print_score()xiaohong.print_score() 奥，语言都是相通的，JavaScript的class和Python思路都是一毛一样啊，不过js中class还有继承、super()、constructor()等等，Python应该也有的，往下继续学习。PS : js中定义的Class，创建实例需要 new 关键字 类和实例 创建类class + className + (继承自某个类) 12class Students(object): def __init__(self, xxx, xx1, xx2): 1234567891011121314class Student extends Person&#123; //js实现 super() //继承基类的属性 constructor(name, age) &#123; //自己的属性 this.speed = 30 this.name = name this.age = age &#125; otherMethods() &#123; //挂载到Student的原型链上 doSth... &#125;, otherMethods1() &#123; //挂载到Student的原型链上 doOther... &#125;&#125; 创建实例12# pyxiaoming = Student(arg) 12// jsconst xioaming = new Student(arg) 看到这，终于深刻体会到了为啥class一定要首字母大写！js里面可能体会不深，因为有 new 关键字在class之前，而py里面，如果不区分，那么很容易搞混class 和 function 特殊方法__init__ 方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。diff:和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 访问限制外部代码还是可以自由地修改一个实例的name、score属性： 12xiaoming = Student('xiaoming', 95)xioaming.score = 12 #可以修改实例的属性 大招来了！！！如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__这个大招js里面可没有啊在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 1234class Student(object): __init__(self, name, age): self.__name = name self__age = age 这样在外部就无法访问到内部的私有变量了，只能调用内部方法来访问。·····~真的是这样的吗？（手动滑稽.jpg）,当然不是啦，之所有我们无法从外部访问到name,是因为Python解释器把该变量变成了 _Studentname ,所以呢，我们可以通过 短线 加 类名 加变量名继续来访问该私有变量吃饱了撑着了吗？哈哈 继承和多态有点C++的感觉了，毕竟js是没有显示的多态的~ 等等，我理解完了，凉凉打脸。Python的多态指的是基类和子类拥有同样的方法时，子类覆盖基类………………emmmm，按照js来说，这就是原型链的查找基本原理啊，先在自己内部找，找不到了就顺着原型链往上查找，一毛一样的……….把py中的class理解为一种数据结构，这个数据结构和py自带的list,tuple,dict 没有任何区别。那么 isinstance() 不就可以用了 12345678xiaoming = Student('xiaoming')isinstance(xiaoming, Student) # True isinstance可以理解为派生class Pupil(Student): passxiaoxioa = Pupil()isinstance(xiaoxiao, Student) # True 隔代的也算派生哦 鸭子模型 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。 获取对象信息 type()判断对象类型，js中使用 typeof() , js判断字符串还可以更为准确的使用Object.prototype.toString().call()题外话了，js的type判断基本类型好用，其他就还是用 instanceof（）这点上，JS和py还是高度相似的！！type() ===== typeof() ===== 基本类型isinstance() ==== instanceof() ===== 判断对象 dir()要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态, js中同理。setAttribute()、getAttribute()、hasAttribute() 实例属性和类属性总结一句话，就是class的类属性各个实例都会访问到，实例的实例属性各自相互独立。可以把这两个概念理解为 JS 基类中的方法，子类都会顺着原型链找到并访问到。 12class Student(object): school = 'hantaiMiddleSchool' #所有实例都可以访问到 面向对象高级编程__slots__slots的作用就是动态给class添加属性的一个约束，否则在class类建立完毕后，运行代码的时候动态随意绑定属性不就乱套了，需要一个约束，职责就是 slotsslots 英文： 插槽。在Vue中使用的广泛，可以理解为在这预先给你留了个位置，以后想用的时候可以用，没有留这个位置的话，以后相用都用不了，可以理解为图书馆同学帮你占座 1234567#pythonclass Student(object): __slots__ = ('name', 'age')&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'xiaoming' # 可以绑定成功&gt;&gt;&gt; s.score = 98 # 会报错，“唉，这位置有人了，你坐不了（手动滑稽.jpg）” PS : 使用slots要注意，slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用 @property解决问题前言：给Class绑定属性时，直接把属性暴露出去，写起来简单，调用起来简单，但是没办法检查参数，导致可以随便修改值。这不合理解决1： 123456789101112131415#Python#Python设置set、get方法来控制属性解决验证问题class Student(onject): def get_score(self): return self.score def set_scsoe(self, value): if not isinstance(value, int): raise ValueError('score must be int') if value &lt; 0 or value &gt; 100: raise ValueError('score must be 0-100') self.score = value 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：总结起来：语法糖，本质没变，但是简化了调用的繁琐程度 12345678910111213141516171819class Student(object): @property def score(self): return self.score @score.setter # 可读可写属性 def score(self, valule): if not isinstance(value, int): raise ValueError('score must be int') if value &lt; 0 or value &gt; 100: raise ValueError('score must be 0-100') self.score = value @property #只读属性 def age(self): return 23#这样，就依旧可以使用属性的.调用方法访问属性、设置属性值了 总结：@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性 多重继承关键字：一个子类可以拥有多个基类、mixinclass需要新的功能，只需要在继承一个基类就可以了，通常，主线都是单一继承下来的 * 为了更好地看出继承关系，我们把主线之外需要继承的基类命名为 Mixin，这样的的设计通常称为 *Mixin 12345678class Person(object): passclass ChineseMixin(Person): passclass ChinaPuple(Person, ChineseMixin): pass 定制类重点：前后双下划线的变量是特殊变量，py有特殊用途的！！__slots____len__()__str____repr____iter____getitem____setitem____getattr____call__上面罗列的方法未查看相关作用，以后需要用到在查看不迟，就最后一个 __call__ ,在js 中调用自身的有 arguments.callee() 枚举类…持续更新…….","categories":[{"name":"Python","slug":"Python","permalink":"http://fanghl.top/categories/Python/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"七月份项目自我总结","slug":"summary201907","date":"2019-08-22T08:16:41.000Z","updated":"2019-11-07T11:50:57.232Z","comments":true,"path":"2019/08/22/summary201907/","link":"","permalink":"http://fanghl.top/2019/08/22/summary201907/","excerpt":"","text":"序言小程序： 相亲小红圈+tool： wepy 传送门：[ wepy ] https://tencent.github.io/wepy/document.html#/[ Vue ] https://cn.vuejs.org/[ ES6 ] http://es6.ruanyifeng.com/[ git ] https://www.liaoxuefeng.com/ 七月份结束，项目上线，回过头来整理一下项目，项目为wepy1.7.0后版本开发的小程序，配套的后台前端使用ant-design-vue开发，上传测试服工具使用Xshell6。 内容 wepy构建工程具体可在wepy官网中查看，此处不多介绍。 1234$ wepy init standard my-project /**创建项目*/$ cd my-project /*进入项目目录*/$ npm install /**安装依赖*/$ wepy build --watch /*运行工程并监控项目修改自动刷新*/ wepy属于类Vue写法，要在wepy中使用异步操作（async/await）需要在工程的app.way入口文件中constructor函数中注册: 12345constructor () &#123; super() this.use('requestfix') this.use('promisify') /*←手动添加这个*/&#125; 生命周期:应用生命周期 属性 type 描述 触发时机 onLaunch Function 生命周期函数–监听小程序初始化 用户首次打开小程序，触发 onLaunch（全局只触发一次） onShow Function 生命周期函数–监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow onHide Function 生命周期函数–监听小程序隐藏 当小程序从前台进入后台，会触发 onHide 页面生命周期 属性 type 描述 触发时机 onLoad Function 监听页面加载，一个页面只会调用一次 小程序注册完成后，加载页面，触发onLoad方法,参数可以获取wx.navigateTo和wx.redirectTo及中的 query参数 onReady Function 监听页面初次渲染完成,代表页面已经准备妥当，可以和视图层进行交互 首次显示页面，会触发onReady方法，渲染页面元素和样式，一个页面只会调用一次 onShow Function 监听页面显示,当redirectTo或navigateBack的时候调用 当小程序有后台进入到前台运行或重新进入页面时，触发onShow方法。 onHide Function 监听页面隐藏,当navigateTo或底部tab切换时调用 当小程序后台运行或跳转到其他页面时，触发onHide方法 onUnload Function 监听页面卸载 当使用重定向方法wx.redirectTo(OBJECT)或关闭当前页返回上一页wx.navigateBack()，触发onUnload。 版本更新版本更新代码，一般较为固定，直接复制在 onLaunch 生命周期内 123456789101112131415161718192021222324if(wx.canIUse('getUpdateManager'))&#123; const updateManager = wx.getUpdateManager(); updateManager.onCheckForUpdate((res) =&gt; &#123; if(res.hasUpdate)&#123; updateManager.onUpdateReady((res) =&gt; &#123; wx.showModal(&#123; title: '更新提示', content: '新版本已经准备好，是否重启应用？', success: function (res) &#123; if(res.confirm)&#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; wx.showModal(&#123; title: '已经有新版本了哟~', content: '新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~' &#125;) &#125;) &#125; &#125;)&#125; 组件组件复用说明： 组件复用，在 同一个页面，一个组件多次复用且每次传入不同的数据源，但是表现出来的数据源全部一致，其他的数据并没有渲染上原因： 组件名一致导致wepy认为是一模一样的组件，如此数据源也不会变动解决： 组件异名化 123456import CompA from &apos;path&apos;components = &#123; CompB: CompA, CompC: CompA,&#125; 这样，既可以重复运用组件 文字换行小程序文字换行： 1&lt;text&gt;第一行\\n第二行\\n第三行\\n&lt;/text&gt; 定时器 页面业务逻辑有需要用到倒计时功能，如下图。 在页面中有需要用到倒计时或者其他定时器任务时，新建的定时器在卸载页面时一定要清除掉，有时候页面可能不止一个定时器需求，在卸载页面（onUnload钩子函数）的时候一定要清除掉当前不用的定时器定时器用来做倒计时效果也不错，初始时间后台获取，前端处理，后台直接在数据库查询拿到的标准时间（数据库原始时间，T分割），前端需要正则处理一下这个时间： 123456let overTimeStr = data.over_time.split('T')let time1 = overTimeStr[0].replace(/-/g,\",\")let time2 = overTimeStr[1].replace(/:/g,',')let overTime = time1+ ',' + time2let overTimeArr = overTime.split(',')this.countDownCtrl( overTimeArr, 0 ); 最终把时间分割为[年，月， 日， 时， 分， 秒]的数组，（如果后端已经把时间处理过了那就更好了），然后把该数组传递给倒计时函数 123456789101112131415161718192021222324252627282930313233countDownCtrl( time, group ) &#123; let deadline = new Date()//免费截止时间，月的下从0开始 deadline.setFullYear(time[0], time[1]-1, time[2]) deadline.setHours(time[3], time[4], time[5]) let curTimeJudge = new Date().getTime() let timeJudge = deadline.getTime()-curTimeJudge let remainTimeJudge = parseInt(timeJudge/1000) if( remainTimeJudge &lt; 0) &#123; log('倒计时已经过期') return; &#125; this.interva1 = setInterval(() =&gt; &#123; let curTime = new Date().getTime() let time = deadline.getTime()-curTime //剩余毫秒数 let remainTime = parseInt(time/1000) //总的剩余时间,以秒计 let day = parseInt( remainTime/(24*3600) )//剩余天 let hour = parseInt( (remainTime-day*24*3600)/3600 )//剩余小时 let minute = parseInt((remainTime-day*24*3600-hour*3600)/60)//剩余分钟 let sec = parseInt(remainTime%60)//剩余秒 hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute : minute sec = sec &lt; 10 ? '0' + sec : sec let countDownText = hour+ \":\" +minute+ \":\" +sec if( group === 0) &#123; //个人业务逻辑，因为一个页面有两个倒计时需求，代码复用区分 this.countDown = countDownText; &#125; else if( group === 1 ) &#123; this.countDownGroup = countDownText &#125; this.$apply() &#125;, 1000 ); &#125; 至此，倒计时效果处理完毕，PS：终止时间一定要大于currentDate，否则显示会出现异常（包括但不限于倒计时闪烁、乱码等） 最后，退出该页面去其他页面时，一定要在页码卸载钩子中清除倒计时！！！ 123onUnload() &#123; clearInterval(this.interva1);&#125; 组件传值组件传值和Vue有点细微区别，Vue强调父组件的数组和对象不要直接传到子组件使用，应为子组件可能会修改这个data，如图： 但是，wepy中，有时候确实需要把一个对象传递到子组件使用，单个传递对象属性过于繁琐，而且！！！如果单个传递对象的属性到子组件，如果该属性是一个数组，则子组件永远会接收到 undefined 。此时最好用整个对象传值替代单个对象属性逐个传值的方法，且一定要在传值时加入 .sync 修饰符，双向传值绑定。确保从接口拿到的数据也能实时传递到子组件，而非 undefined :circleMembersList.sync=&quot;circleMembersList&quot; 阻止组件的点击事件传播解决： 添加函数 catchtap=”funcName” 即可，funcName可为空函数，也可以直接不写 token判断 小程序调试时，有时候会出现首次打开无内容（拿不到数据）的状态，需要“杀死”小程序再打开才能看到数据内容，其中可能的原因之一便是 token 的失效。在与后台交互的时候，token必不可少。尤其是在小程序分享出去的链接，由其他用户点开分享链接进入小程序内部，此时更是要判断token，token的判断一般选在 onShow（）钩子执行而不在 onLoad（）钩子内执行。若不存在token，则应该执行登录去拿取token，再进行业务逻辑 1234567891011onShow() &#123; const that = this; if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) &#125; &#125;); &#125; &#125; formid 微信提供了服务通知，即在你支付、快递等行为时，微信会直接给你发一个服务通知（模板消息）来提醒，每次提醒都会消耗该用户存储的formID，formID为消耗品，用一个少一个，只有通过用户的表单提交行为才可以积攒formID 12345678&lt;form @submit=\"submitForm\" report-submit=\"true\"&gt; &lt;button form-type=\"submit\" class=\"editCard\" @tap = \"goModifiPage('editFormTab')\"&gt;修改&lt;/button&gt;&lt;/form&gt;//js方法submitForm(e) &#123; this.postFormId( e.detail.formId ) // 向后端传输formid&#125; 支付 准备： crypto-js.js &amp;&amp; md5.js 微信支付流程为： 前端点击支付按钮拉起支付 ==》 准备加密数据 ==》 调用后端接口，传入需要的加密数据 ==》 后端验证加密数据，再返回加密数据 ==》 前端拿到后端加密数据（时间戳、内容、签名），对时间戳和内容进行本地签名，再判断本地签名和后端签名是否一致，若不一致，直接返回，退出支付，支付失败！若一致，对刚刚后台返回的content（内容）进行解析，拿到所需订单数据，前端拉起微信支付，参数传入刚刚解析数据 ===》 得到支付结果 success or fail ！结束 12345678/** * 签名函数 Sign */function sign(timestamp, content) &#123; var raw = timestamp + salt + content var hash = CryptoJS.SHA256(raw).toString() return CryptoJS.MD5(hash).toString()&#125; 前端点击支付按钮： 123456789101112131415161718192021222324252627// 单独支付接口alonePay(arg) &#123; const that = this; if( that.buttonClicked === false ) return; //防止重复多次拉起支付 that.buttonClicked = false; let mode = 1; //业务需求，我有五种不同模式支付 let appId = this.$parent.globalData.appId; let content; let sign; const timeStamp = new Date().Format(\"yyyy-MM-dd hh:mm:ss\").toString(); let code = wepy.getStorageSync('code'); wepy.login().then((res) =&gt; &#123; //获取最新的code，可能这里没必要，具体和后端商量 if(res.code) &#123; let code = res.code; log('code', code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;).then( res =&gt; &#123; content = `mode=$&#123;mode&#125;&amp;app_id=$&#123;appId&#125;` sign = Sign.sign(timeStamp,content); &#125;).then(res =&gt; &#123; that.goCirclePay( that.circle_id, timeStamp, sign, content, mode ) &#125;)&#125;, 支付函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 支付函数，我前端有五种支付情况（单独、自己发起拼团、拼别人团、ios、免费五种支付），所以单独抽出支付，每次调用支付函数goCirclePay( circle_id, timestamp, sign, content, mode) &#123; const that = this; circleApi.goCirclePay(&#123; data: &#123; circle_id, timestamp, sign, content &#125;, getToken: true &#125;).then( res =&gt; &#123; log('支付res：', res) let data = res.data const SignServer = data.sign const timeStampServer = data.timestamp let contentServer = data.content const SignLocal = Sign.sign(timeStampServer,contentServer); if( mode === 0 &amp;&amp; data.status === \"success\") &#123; that.nav('/pages/circleDetail?circle_id=' + that.circle_id) return; &#125; if( SignLocal !== SignServer ) &#123; log('签名不一致！') wx.showToast(&#123; title: \"您已经支付过了\", duration: 1500, image: \"../images/common/icon_wxchat.png\", &#125;) return &#125; let contentArr = contentServer.split('&amp;') const timeStamp = contentArr[0].split('=')[1]; const nonceStr = contentArr[1].split('=')[1]; let index = contentArr[2].indexOf(\"=\"); const package1 = contentArr[2].slice(index+1) const signType = contentArr[3].split('=')[1]; const paySign = contentArr[4].split('=')[1]; wepy.requestPayment(&#123; timeStamp, nonceStr, package: package1, signType, paySign &#125;).then(res =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;) &#125;).then(res =&gt; &#123; //支付后promise，这里有成功和fail两种，fail在catch捕获，这里直接开始写支付success后的业务代码 that.buttonClicked = true; let groupFormIdGet; circleApi.getGroupFormId(&#123; ////获取getGroupFormId data: &#123; circle_id: that.circle_id &#125;, getToken: true &#125;).then( res =&gt; &#123; // let data = res.data that.group_form_id = data.group_form_id groupFormIdGet = data.group_form_id if( mode === 1) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;shareLink=$&#123;that.shareLink&#125;`) &#125; else if( mode === 2) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;group_form_id=$&#123;groupFormIdGet&#125;`) &#125; that.$apply() //脏值检查触发 &#125;) &#125;).catch(res =&gt; &#123; log('支付失败', res) that.buttonClicked = true; &#125;) &#125;)&#125; 图片上传（七牛云） 更多图床网站请见我博客： https://www.cnblogs.com/fanghl/p/11419914.html 图片上传服务器采用七牛云服务，在app.wpy内小程序触发的时候，请求七牛云拿到token存为全局变量。 123456789101112//app.wpyonLaunch() &#123; //other code *** // 七牛云,获取七牛云token wepy.request(&#123; url: 'https://****************/qiniu_token/', header:&#123;'content-type': 'application/json'&#125;, &#125;).then((res) =&gt; &#123; this.globalData.qiniuToken = res.data.token &#125;);&#125; 导入七牛云文件import qiniuyun from &#39;@/utils/qiniuUploader&#39; base.js代码： 1234567891011121314// 上传图片 base.jsconst uploadImg = (imageURL, uptokenURL) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; qiniuyun.upload(imageURL, (res) =&gt; &#123; resolve(res); &#125;, (error) =&gt; &#123; reject(error); &#125;, &#123; region: 'ECN', domain: '填入域名', uptoken: uptokenURL &#125;); &#125;); &#125; 页面结构 12345678910111213141516&lt;!-- 上传生活照 --&gt; &lt;view class=\"baseInfoTip\" style=\"border: 0\"&gt;上传生活照 &lt;view class=\"imgUploadText\"&gt;(最多9张)&lt;/view&gt; &lt;view class=\"leftOriginLine\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"uploadImgBox\"&gt; &lt;repeat for=\"&#123;&#123;images&#125;&#125;\" index=\"index\" item=\"item\" key=\"index\"&gt; &lt;view class=\"itemBox\"&gt; &lt;image class=\"imgItem\" src=\"&#123;&#123;item&#125;&#125;\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;image class=\"imgItemCancel\" id=\"&#123;&#123;index&#125;&#125;\" src=\"../images/common/icon_cardImg_cancel.png\" @tap.stop=\"cancelUploadImg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/repeat&gt; &lt;view class=\"itemBox\" @tap=\"addImg\" wx:if=\"&#123;&#123;!addImgCtrl&#125;&#125;\"&gt; &lt;image class=\"imgItem\" src=\"../images/common/icon_addImg.png\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; 上传图片业务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 从相册选择照片上传addImg()&#123; const that = this; if( that.buttonClicked === false ) return; that.buttonClicked = false; wepy.chooseImage(&#123; count:9 - that.images.length, sizeType: 'compressed', &#125;).then(async(res1) =&gt; &#123; that.buttonClicked = true; that.toast('上传图片中...','loading'); let filePath = res1.tempFilePaths; for(let i = 0;i &lt; filePath.length;i++)&#123; let imgSrc= res1.tempFilePaths[i]; let imgType = imgSrc.substring(imgSrc.length-3); let imgSize = res1.tempFiles[i].size; if(imgSize &gt; 2000000 || imgType === 'gif')&#123; that.toast('该图片格式错误！请重新选择一张', 'none', 3000); continue &#125; let res = await base.uploadImg(filePath[i], that.$parent.globalData.qiniuToken); that.images.push(res.imageURL); log('image长度：', that.images.length) log('image：', that.images) if( that.images.length &gt;= 9) &#123; that.addImgCtrl = true &#125; if(that.images.length &gt; 9)&#123; that.images = that.images.slice(0,9) &#125; if(that.images.length &gt;0 &amp;&amp; that.config.fImages)&#123; that.config.progress = that.config.progress + parseFloat(that.config.getConfigs.lifepicweight*100); that.config.fImages = false &#125; that.$apply(); // 上传用户头像列表 that.userInfo.photos = that.images if(i === filePath.length -1)&#123; wepy.hideToast(); &#125; &#125; &#125;).catch((res) =&gt; &#123; if(res.errMsg === \"chooseImage:fail:system permission denied\")&#123; that.toast('请打开微信调用摄像头的权限', 'none', 3500) &#125; &#125;)&#125;,// 取消图片上传cancelUploadImg(e) &#123; if( this.images.length &lt; 10 ) &#123; this.addImgCtrl = false &#125; let index = e.target.id this.images.splice(index, 1)&#125;, 微信消息聊天布局微信聊天框整体布局特点有： 接收方和发送方消息分别位于屏幕的左右两侧、最新的消息一定是在屏幕最底部、进入消息dialog页面一定是显示的最新消息，即页面滑动在最底部。这三个基本特征构成了微信聊天页面的布局原则。先看效果图 （非最终效果）：↓布局思路：flex反向布局 1234567891011121314151617&lt;!-- 格式化代码 --&gt;&lt;view class=\"msgBox\" id=\"msgBox\"&gt; &lt;repeat for=\"&#123;&#123;talkContent&#125;&#125;\" key=\"index\" item=\"item\"&gt; &lt;view class=\"msgItem &#123;&#123;item.send_user === configData.send_user ? 'msgItemReverse' : ''&#125;&#125;\"&gt; &lt;image class=\"adverseHeadimg\" src=\"&#123;&#123;item.send_user === configData.send_user ? configData.user_img : talkAimerInfo.headimg&#125;&#125;\" mode=\"aspectFill\"&gt; &lt;/image&gt; &lt;text class=\"textBox &#123;&#123;item.send_user == configData.send_user ? 'textGreen' : ''&#125;&#125;\" selectable=\"true\"&gt; &#123;&#123;item.message&#125;&#125; &lt;/text&gt; &lt;/view&gt; &lt;view class=\"timeTip\" wx:if=\"&#123;&#123;item.send_user != configData.send_user&#125;&#125;\"&gt; &#123;&#123;item.create_time&#125;&#125; &lt;/view&gt; &lt;/repeat&gt;&lt;/view&gt; 1234.msgBox&#123; display: flex; /*整体消息框flex布局，纵向取反布局*/ flex-direction: column-reverse;&#125; 12345678.msgItem&#123; /*消息item样式*/ position: relative; display: flex; flex-direction: row;&#125;.msgItemReverse&#123; /*对方的消息样式，flex行取反布局*/ flex-direction: row-reverse;&#125; 保持页面始终滑动在最底部函数 12345678910pageScrollToBottom( msgLength ) &#123; //在页面需要进行变化时调用 wx.createSelectorQuery().select('#contentBox').boundingClientRect(function(rect)&#123; // 使页面滚动到底部 log('rect', rect) wx.pageScrollTo(&#123; scrollTop: rect.bottom + msgLength*60, duration: 80 &#125;) log('msgBox的下边界坐标： ', msgLength ) &#125;).exec() &#125; 自己发送的消息数据可以直接压入本地数组 talkContent 内，Unshift()进入，得到“负负得正”效果，即数据反，布局反即可得到从底部排列的布局。对方的消息从服务器拉下来的时候，放入 talkContent 内前 reverse() 一下即可 CSS注意点CSS持续补充中……word-break: break-all; //换行文字，英文溢出-webkit-overflow-scrolling: touch; //ios端启用硬件加速，解决ios端滑动粘手catchtouchmove=&#39;true&#39; //模态框中添加，禁止页面滑动circleDynamic:last-of-type //特定类circleDynamic中最后一个元素:nth-of-type(1/odd/even) //选择特定元素下第几个元素 123 /* CSS 吸顶 */position: sticky; top: 0; async/await异步编程的终极解决方案，在小程序内拿取code或者login时会用到，await可理解为求值！async可理解为搭配await的语法，如果异步函数去掉await，返回的一般是 promise 对象，需要手动去reject 和 resolve 。 123456789101112if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;); &#125; else &#123;&#125; ios/android机型区别由于微信小程序的运行规范限制等，一些在 Android 上可以存在的业务需求并不能原封不动在 ios 端运行，否则小心 封号警告 （此处手动滑稽.jpg）,所以一般采取两个系统的用户进入某一个页面，展现不同的内容。判断机型：在 app.wpy 入口文件中，onlaunch 生命周期内判断机型并保存到全局变量即可 12345678getSystemInfo() &#123; const that = this; wx.getSystemInfo(&#123; success(res) &#123; that.globalData.userPlatform = res.platform; &#125; &#125;)&#125; 分包微信小程序官方限制小程序代码大小不得超过 2M ，在业务逻辑较多的情况下，查过2M后，我们可以采用分包加载。 1234567891011121314151617181920//app.wpyconfig = &#123; pages: [ &apos;basePage1&apos;, &apos;basePage2&apos;, &apos;basePage3&apos;, ], subPackages: [ &#123; root: &apos;dirName&apos;, //通常结构和 pages: [ &apos;subPage1&apos;, &apos;subPage2&apos;, ] &#125; ]&#125;//页面使用：this.nav(`/dirName/pages/subPage1`) 持续更新…….","categories":[{"name":"工作总结","slug":"工作总结","permalink":"http://fanghl.top/categories/工作总结/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"firstBlog","slug":"firstBlog","date":"2019-08-19T07:02:47.000Z","updated":"2019-10-21T05:54:43.606Z","comments":true,"path":"2019/08/19/firstBlog/","link":"","permalink":"http://fanghl.top/2019/08/19/firstBlog/","excerpt":"","text":"#既昨天搞崩GitHub博客，再次坚强的尝试 既昨天搞崩GitHub博客，再次坚强的尝试既昨天搞崩GitHub博客，再次坚强的尝试####既昨天搞崩GitHub博客，再次坚强的尝试 #####既昨天搞崩GitHub博客，再次坚强的尝试 1alert('hello world')","categories":[{"name":"test","slug":"test","permalink":"http://fanghl.top/categories/test/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://fanghl.top/tags/Programming/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-15T12:43:17.000Z","updated":"2019-10-21T05:54:43.611Z","comments":true,"path":"2019/08/15/hello-world/","link":"","permalink":"http://fanghl.top/2019/08/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}